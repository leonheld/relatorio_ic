\documentclass[12pt, a4paper]{report}
\usepackage[portuguese]{babel}
\usepackage{csquotes}
\usepackage{lipsum}
\usepackage{graphicx}
\usepackage{pdfpages}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{textcomp}
\usepackage{float}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric}
\usepackage[utf8]{inputenc}
\usepackage{indentfirst} %\section or \chapter by default don't indent the first paragraph for some absurd reason!

\usepackage[style=abnt]{biblatex}
\addbibresource{references.bib}        % Seus arquivos de

\begin{document}
\begin{titlepage}
    \begin{center}
        \vspace*{1cm}
        \Huge
        \textbf{INVESTIGAÇÃO DE SONS RESPIRATÓRIOS ADVENTÍCIOS PARA AUXÍLIO AO DIAGNÓSTICO DE ENFERMIDADES PULMONARES}
             
        \vspace{1.5cm}

        Relatório Final de \\
        pesquisa de Iniciação Científica\\

        PIBIC 2019/2020\\
 
        \vfill
        \Large
        \textbf{Aluno: Leonardo José Held}\\
        \textbf{Orientador: Raimes Moraes}
        \vspace{0.8cm}

        Departamento de Engenharia Elétrica e Eletrônica\\
        Curso de Graduação em Engenharia Eletrônica\\
        Universidade Federal de Santa Catarina\\
        Brasil\\
        %TODO:
        
             
    \end{center}
 \end{titlepage}
 \Large

 \tableofcontents

\newpage
Os códigos referentes ao projeto (códigos de software embarcado, aplicativo para laptop/microcomputador e o próprio código desse documento) podem ser acessados pelo seguinte link: 

\url{github.com/leonheld/bluetooth-stethoscope}
\\
\newpage
\chapter*{Resumo}
\label{sec:Resumo}
\addcontentsline{toc}{chapter}{\nameref{sec:Resumo}}

Entre os diversos métodos de diagnóstico de enfermidades pulmonares, a asculta de sons respiratórios sobre o toráx tem como vantagens o fato de ser  não invasivo e ter baixo custo. No entanto, devido à fatores técnicos como qualidade do estetoscópio, acurácia auditiva do examinador e atenuação do som pelo toráx do paciente, além da subjetividade pelo fator humano envolvido no exame, há esforços para tornar este método mais robusto, proporcionando um diagnóstico mais confiável. Este trabalho tem como objetivo aperfeiçoar estetoscópio eletrônico desenvolvido neste laboratório que digitaliza e transmite sons respiratórios para armazenamento remoto, bem como, registra o deslocamento do tórax para identificação da fase respiratória. O sistema consiste-se de dois módulos, transmissor e receptor, que respectivamente amostram e recebem o som em um microcomputador pessoal para armazenar os sons captados de pacientes. O protocolo de transmissão utilizado é o \textit{Bluetooth 5.0}. Neste trabalho, são reportados o estudo, teste e o aprimoramento do sistema.

Palavras-chave: Instrumentação médica. Sistema respiratório. Sons respiratórios. Estetoscópio Eletrônico. Processamento Digital de Sinais.

\newpage

\setcounter{chapter}{0}
\chapter{Introdução}

O prematuro diagnóstico de enfermidades respiratórias pode representar uma redução significativa de óbitos. Dentre os métodos de diagnóstico, tem-se a asculta pulmonar, rotineiramente realizada  por médicos treinados. Seus pontos fortes são o baixo custo e o baixo tempo de resposta,  não demandando  o deslocamento de pacientes acamados para salas de exames\cite{carvalho}. No entanto, o diagnóstico é fortemente dependente da experiência e capacidade auditiva do examinador. Neste contexto, surgiram estetoscópios eletrônicos de baixo custo que podem captar e registrar sinais que podem ser digitalmente processados com o objetivo de prover indíces quantitativos para orientar o diagnóstico, de tal forma a tornar o diagnóstico menos subjetivo e permitir a troca de informações entre especialistas. Esse trabalho propõe o aprimoramento com integração de funcionalidade adicionais a  um sistema de aquisição de sons respiratórios desenvolvido no LCS - UFSC. O módulo \cite{willian}, - que antes contava com receptor e transmissor \textit{Bluetooth 5.0}, e um periférico de aquisição de sinais analógicos - foi aprimorado com a integração de sensor para registro da fase respiratória.

\section{Objetivo}

Este trabalho objetivou o aprimoramento de sistema de captação de sons respiratórios anteriormente desenvolvido, adequando-o para a aquisição de sons respiratórios em ambiente hospitalar.

Como desenvolvimento adicional, acrescentou-se sensor para registrar deslocamento da parede torácica para identificar a fase respiratória. 

\chapter{MATERIAL E MÉTODOS}


\section{Introdução}

%TODO: Consertar essa figura. Não fica bonito ter a figura sem texto antes, mas ela não cabe no restante da página. Se deixar muito pequena fica pouco legível.
\begin{figure}
    \centering
    \includegraphics[width=0.9\textwidth]{esquematico_novo.png}\\
    \caption{Fonte: O autor.}
\end{figure}

A Figura 2.1 apresenta o diagrama em blocos do sistema desenvolvido em trabalho anterior \cite{willian}, com a inclusão dos aprimoramentos projetados neste trabalho: interface acelerômetro e giroscópio, botão para atendimento de interrupção externa e aplicativo de captação serial e armazenamento de dados.

O sistema possui módulo para a captação de sons respiratórios (\textbf{Módulo 1}, figura 2.1), módulos de amostragem (via os periféricos \textbf{Módulo 2.1} e \textbf{Módulo 2.2}) e recepção de dados (\textbf{Módulo 3} e \textbf{Módulo 4}, respectivamente), bem como de aplicativo para sistema operacional (\textbf{Módulo 5}). Este aplicativo objetiva o armazenamento e reprodução das formas de onda amostradas. O aplicativo conta com programa escrito em Python (desenvolvido neste trabalho) que obtém os dados recebidos pelo USB - via serial - do módulo de Recepção, capturados pelo módulo de Amostragem, que realiza o envio utilizando protocolo Bluetooth.

Estas etapas são realizadas por meio do kit de desenvolvimento BLE da Texas Instruments (\texttt{LAUNCHPAD-XL Kit}). Este kit com protocolo Bluetooth 5 proporciona uma considerável redução no tempo de desenvolvimento da solução BLE, oferecendo taxa de transmissão e consumo de energia que atendem às necessidades do projeto.

A transmissão por tecnologia \textit{Bluetooth} em sua versão 5.0 foi selecionada devido a larga banda dados que devem ser transmitidos, visto que os sons respiratórios gravados são de alta fidelidade, e transmitidos sem compressão.

Para administrar todo este conjunto de tarefas, o módulo \texttt{LAUNCHPAD-XL Kit} utiliza um sistema operacional em tempo real proprietário da Texas Instruments (TIRTOS).
Para melhor compreensão do sistema existente, detalha-se nas próximas seções o kit de desenvolvimento, o protocolo Bluetooth e o TIRTOS.


\label{sec:hardware}
\section{Características de módulos microcontrolados com capacidades \textit{BLE 5.0}}

Ambos módulos de Amostragem e Recepção (módulos 3 e 4, respectivamente na figura 2.1) dos dados são placas de desenvolvimento da \textit{Texas Instruments}\textsuperscript{\textregistered}, codenome \texttt{LAUNCHPAD-XL} contendo o chip \textit{CC2640R2} e que suportam a tecnologia \textit{Bluetooth Low Energy 5.0}.

O Módulo de Amostragem (módulo 3, figura 2.1) controla a digitalização dos sinais do ADC via interface SPI, empacota as amostras e os transmite por radiofrequência (Bluetooth) para o módulo de recepção (módulo 4, figura 2.1). 

O dispositivo \texttt{LAUNCHPAD-XL} (figura 2.2) baseia-se em processador ARM\textsuperscript{\textregistered} Cortex\textsuperscript{\textregistered}-M3 que gerencia a camada de aplicação e a pilha de protocolos BLE. Além disso, possui um sistema autônomo de rádio (utilizando um processador ARM Cortex\textsuperscript{\textregistered}-M0) que gerencia todo o controle e processamento das camadas inferiores associadas à camada física e partes da camada de enlace. 

\begin{figure}
    \centering
    \includegraphics[width=0.4\textwidth]{cc2640r2.jpg}\\
    \caption{Fonte: Texas Instruments\textsuperscript{\textregistered}}
\end{figure}


Como pode ser observado no esquemático funcional de blocos do chip \textit{CC2640R2} (figura 2.3), ambos os módulos contam com dois processadores: ARM Cortex-M3 e ARM Cortex-M0. O primeiro atua como processador de propósito geral, supervisionando os pinos de entrada e saída (\textit{I/O}) de cada placa. O Cortex-M0 controla o circuito de radiofrequência (\textit{RF}) responsável pela implementação do protocolo \textit{Bluetooth} da placa. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{soc_cc2640.png}\\
    \caption{Fonte: Texas Instruments\textsuperscript{\textregistered}}
\end{figure}

Existe um protocolo de comunicação entre os dois processadores (não acessível ao usuário da placa) para viabilizar transmissão de dados pelo Bluetooth. Fazemos uso, então, do \textit{Cortex-M3} para acessar e obter dados dos sensores ou periféricos. Estes, por sua vez, são enviados via bluetooth para o módulo de recepção (segundo kit \texttt{LAUCHPAD-XL}) usando a API da \textit{TI}.
 %TODO: Referência do documento da API da TI

 Algumas limitações de hardware ainda existem para implementar o protocolo de comunicação \textit{BLE 5.0}. Embora o protocolo da tecnologia \textit{BLE 5.0} tenha sido homologado em 2016, ainda não é totalmente adotada e nem amplamente utilizada. Visto que o ecossistema do projeto original já estava baseado nesta plataforma, o atual projeto continuou sendo desenvolvido na mesma.

 \subsection{Bluetooth}
 O \textit{Bluetooth 5.0}, como definida pelo grupo de trabalho denominado \textit{Bluetooth Special Interest Group}, é um padrão de comunicação sem fio entre dois - ou mais - dispositivos numa banda de frequência normalmente utilizada para fins industriais, científicos e médicos\cite{SIG}. Originalmente, o Bluetooth foi criado para estabelecer um tipo de comunicação simples, serial, que já existe na forma de conexão via cabo entre dispositivos.
 
 De acordo com \cite{omre}, os principais pontos que fazem com que \textit{Bluetooth} sejam uma boa escolha meios médicos são: interoperabilidade, baixo consumo, adaptação de formato de transmissão (pacote), compatibilidade eletromagnética (equipamentos médicos coexistem, não podendo causar interferências uns aos outros), segurança na transmissão para proteger confidencialidade da informação e hub de sensores (diversos equipamentos médicos precisam ser atualizados em tempo real via internet para fins de telemedicina). 
 
 A necessidade de se utilizar tal protocolo nesse projeto surge da já mencionada grande quantidade de dados envolvidos na transferência de sons respiratórios. Na especificação do \textit{Bluetooth Low Energy}, um padrão de Bluetooth caracterizado pelo baixo consumo, com alcance de até 350 metros, o \textit{throughput} é limitado em 2Mpbs\cite{Panwar}, dado um \textit{overhead} dependente do hardware onde o protocolo está sendo executado, a velocidade efetiva de transmissão é geralmente menor do que a especificada.
  
 Também é um protocolo aberto para implementação, realizado pelas principais empresas de tecnologia mundiais, fomentando interoperabilidade de equipamentos e segurança. 

\subsection{Sistemas Operacionais em Tempo Real}

Devido à necessidade de aquisição de diferentes sinais em intervalos de tempo regulares (de tal forma a atender ao teorema da amostragem), emprega-se Sistema Operacional em Tempo Real (a partir daqui denominado RTOS:  Real Time Operating System)  que é executado em ambos os módulos (transmissão e recepção). 

De acordo com \cite{freertos} um Sistema Operacional em Tempo Real precisa executar tarefas dentro de limites rígidos de tempo para que se tenha a impressão que múltiplas atividades (processadas por uma única central de processamento) estejam sendo realizadas ao mesmo tempo. Ou seja, um sistema em tempo real se carateriza pelo caráter determínistico. É ideal para aplicações onde ações externas precisam ser induzidas em intervalos de tempo regulares e extremamente corretos, como aquisição de som - no caso de estudo deste trabalho - ou o disparo de um air-bag.

O princípio de funcionamento básico de um RTOS é fazer com que várias rotinas (também chamadas de funções) possam ser executadas em \textit{quasi-}paralelismo. Ou seja, eficientemente alocando tempo de execução de código em um único processador para concluir várias tarefas diferentes, criando uma ilusão de paralelismo entre as mesmas. "Tempo Real" se refere aos padrões rígidos que o sistema impõe para execução de tarefas \cite{tanenbaum}.

A principal estrutura de dados de um Sistema Operacional é o de \textit{Task}, \textit{Tarefa} ou \textit{Thread}. É uma estrutura contendo:

\begin{enumerate}
    \item A rotina (ou função) que deverá ser executada.
    \item Metadados sobre que acompanham a rotina. Estes são o modo atual de execução da rotina, sua prioridade e tamanho de memória disponível para o uso da rotina.
  \end{enumerate}

  Os metadados sobre a execução de uma tarefa, chamados de estado de execução mudam durante a execução da tarefa e podem ser \texttt{READY, RUNNING, BLOCKED} ou \texttt{TERMINATED}. A passagem de um estado para outro é sempre igual, e compõe a "vida de execução" de uma tarefa \cite{tirtosguide}. 

A Figura 2.4 mostra as diferentes  etapas relacionadas à execução de tarefas num RTOS - utilizando como exemplo o TIRTOS -, e as funções que realizam a troca de estados de uma task.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{task_execution.png}\\
    \caption{Fonte: Texas Instruments}
\end{figure}

Existem três blocos conceituais dentro de um Sistema Operacional: O \textit{Kernel}, \textit{User Space} e os \textit{Middleware}. Essa divisão objetiva segregar regiões de memória, afim de manter segurança na execução de aplicações \cite{tanenbaum}.

O Kernel é a parte que tem controle total sobre o sistema, possuindo acesso irrestrito à memória do sistema, sendo responsável pelo controle das interações entre software e hardware, alocando recursos e executando tarefas.

O \textit{User Space} carateriza a parte da memória onde programas de usuário podem ser carregados, e pode-se acessar funcionalidades do hardware via uma textit{API - Application Programming Interface}. Essa API constitui-se em um exemplo de \textit{Middleware}. Outros tipos de middleware são códigos relacionados com conectividade (Bluetooth, TCP/IP), sistemas de arquivo ou gerenciamento de energia dos módulos embarcados.

\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.15]{os_esquematico.png}
    \caption{Fonte: O autor}
\end{figure} 

O programa que realiza a funcionalidade de \textit{quasi-}parale-\\lismo num RTOS é o escalonador, que reside no Kernel. A função principal do escalonador é criar uma fila das tarefas disponíveis escritas pelo programador e garantir que estas sejam executadas dentro de um tempo limite chamado de \textit{time-slice} (na ordem de microssegundos). O escalonador pode ser observado, essencialmente, como um algoritmo de organização que minimiza o tempo de execução levando em consideração os metadados de cada tarefa\cite{tanenbaum}.

Para garantir que cada tarefa possa ser executada dentro do \textit{time-slice}, o escalonador faz, dinamicamente, a \textit{preempção} de quaisquer tarefa por outra. 

Ou seja, se uma tarefa está sendo executada (modo de execução \texttt{RUNNING)}, o escalonador pode parar a execução da mesma se 

\begin{itemize}
    \item Seu \textit{time-slice} tiver esgotado ou
    \item Exista outra tarefa de prioridade mais alta que esteja no estado \texttt{READY}.
  \end{itemize}

Tais sistemas são de suma importância para diversas aplicações na indústria e na ciência, sendo exaustivamente utilizado em diversos setores, como robótica, equipamentos biomédicos e quaisquer sistemas sensíveis a rígidas demandas de tempo. A compreensão desses mecanismos são essenciais para a programação do firmware dos módulos de recepção e amostragem.

A Texas Instruments disponibiliza juntamente com os \texttt{LAUCHPAD-XL} um Sistema Operacional em Tempo Real denominado \texttt{TIRTOS} bem como bibliotecas de desenvolvimento (SDK), este último contendo um Middleware que possibilita a utilização do hardware de radiofrequência que implementa o protocolo Bluetooth presente na plataforma. 

O TI-RTOS é um kernel capaz de gerenciar funções e tratadores de interrupção, levando em consideração questões de tempo de execução e prioridade\cite{tirtosguide}. A empresa, no entanto, não disponibiliza o código do mesmo, mas sim uma \textit{API - Application Programming Interface}, que permite seu uso. Essa \textit{API} contém \textit{drivers}, ou camadas de abstração entre o código e o hardware. Por exemplo, um driver de \textit{timer}, ou um driver de periférico como \textit{SPI}.

Entre essas APIs, existem drivers de periféricos (como SPI, timers e pinos de propósito geral), mecanismos de criação de tarefas e sistemas de gerenciamento de energia das placas.

A empresa também disponibiliza uma \textit{IDE - Integrated Development Environment}, ou Ambiente Integrado de Desenvolvimento chamado \texttt{Code Composer}. Esse ambiente contém um editor de texto, compilador, depurador e várias ferramentas de análise em tempo real para diversas plataformas.

Esta IDE disponibiliza exemplos de aplicação que podem ser extendidos e modificados livremente, sob licença aberta. Um desses é o \textit{Simple Port Profile}, que é um firmware para conectar duas placas de desenvolvimento \textit{LAUNCHPAD-XL} de tal forma a transferir dados numa configuração bidirecional entre as duas.

Esse exemplo foi compilado, estudado e analisado, visando compreendimento base do Sistema Operacional. O projeto também usa esse exemplo de aplicação como projeto-base.

\section{Desenvolvimento de firmware para testes de sinais simulados de aúdio}

A partir disso, foram iniciados estudos sobre como o sistema de aquisição e transmissão criado por \cite{willian} (figura 2.6). Durante esse passo, notamos as limitações promovidas pela construção e configuração padrão do hardware da plataforma \textit{CC2640R2}. 

O principal esforço se deu a trabalhar dentro de limitações extremas de memória volátil (memória não persistente). Com apenas 8\texttt{kb} de memória do tipo volátil, sendo que o Sistema Operacional em uso pode ocupar cerca de $25\%$ desse valor, fazendo com que inserção de rotinas novas necessitem de cuidado para evitar possíveis \textit{overflows}, ou estouro de memória por sua insuficiência.
\newpage
O sistema conta com um \textit{ADC} de 16 \textit{bits} de dois canais modelo \textit{LTC1867LCGN} da \textit{Linear Devices\textsuperscript{\textregistered}}. Este se conecta a uma front-end desenvolvida por \cite{speranza}.

\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{estetoscopio.jpg}\\
    \caption{Fonte: \cite{willian}}
\end{figure}

O projeto pode ser utilizado para se obter sinais de com pouca interferência de sons do ambiente e artefatos de movimento. Os sinais podem, \textit{a posteriori} ser processados e analisados por técnicas específicas de processamento de sinal. A interface também pode ser vista como um estetoscópio eletrônico de baixo custo e performance comparável aos dispositivos existentes no mercado, que são de código fechado e valor proibitivo para uma grande parcela de possíveis aplicações.

A comunicação \textit{ADC} \textrightarrow \textit{CC2640} é realizada pelo padrão \textit{SPI} com as seguintes configurações:

%TODO: Inserir aqui figura (na real montar um tabular que fica mais limpo) das configurações da SPI. 12MHz e tal e tal

    \begin{table}[ht]
        \centering
            \begin{tabular}{|l|l|}
            \hline
            \textbf{Parâmetro}                    & \textbf{Valor} \\ \hline
            Modo de comunicação CC2640R2 & Mestre \\ \hline
            Modo de comunicação LTC1867L & Escravo \\ \hline
            Taxa do clock                & 12MHz \\ \hline
            Tamanho da Amostra           & 16 bits \\ \hline
            CPOL (Clock Polarity)        & 0 \\ \hline
            CPHA (Clock Phase)           & 0 \\ \hline
            Modo                         & Callback \\ \hline
        \end{tabular}
        \caption{Parâmetros de configuração \textit{SPI}}
    \end{table}
            
Foram corrigidos avisos gerados por conversões digitais implícitas que existiam nos valores amostrados do \textit{ADC} quando levadas ao buffer de transmissão utilizado pelo projeto.

Para disparar a aquisição desse periférico é utilizado um relógio em modo periódico que faz a requisição dos sinais a cada $100\mu s$.

O sistema foi então testado com sinais tanto gerados pelo próprio microcontrolador ou externos e obteve resposta satisfatória.


\section{Desenvolvimento de Aplicativo para Notebook}

O projeto original também conta com um aplicativo para Notebooks e Computadores Windows, que captura os pacotes transmitidos via Bluetooth pelo \textit{Client} do sistema por emulação de porta serial via USB. O primeiro problema foi a falta de documentação sobre o projeto, que não provinha de instruções de compilação. As bibliotecas utilizadas no projeto eram versões antigas, com diversos problemas de interoperabilidade.

Ultrapassando o problema de compilação do projeto, percebemos que o mesmo utilizada a \textit{API} do próprio sistema Windows NT. O código utilizado para acesso ao periférico da porta serial emulada sobre USB era datado, não se comportando bem em novas versões do sistema Windows NT. Decidimos então criar um novo programa que adquirisse as informações de quaisquer porta serial, com a necessidade de fácil manutenção e pouca modificação entre sistemas operacionais host. Dessa forma, foi escrito um programa na linguagem de programação \texttt{Python 3.8} que obtém os dados da porta serial e os salva para pós-processamento, tendo demonstrado bom desempenho. Se necessário, métodos de pós-processamento podem ser programados, gerando os dados de maneira rápida.

Outra vantagem desse novo programa é que o mesmo foi escrito com princípios de programação \textit{concorrente}. No programa anterior, caso o usuário estivesse fazendo aquisição de dados, o programa necessariamente teria terminar a aquisição para começar outra rotina ("travando" a tela do programa), não fazendo total uso da capacidade processamento disponível nos notebooks e microcomputadores modernos.

Essa capacidade fez uso da biblioteca \texttt{asyncio}\cite{asyncio}, de Python, que implementa código concorrente baseado em \texttt{async/await}.

Esse programa também define um tratador de códigos de operação e uma interface estilo \textit{Shell} entre as partes integrantes do sistema. Via códigos predefinidos, se pode ativar operações em quaisquer uma das placas. Esse método será utilizado na implementação da inicialização da aquisição de sinais via interrupção externa (próxima seção).

\subsection{Código para atendimento de interrupção externa}

Considerando que acessar o equipamento notebook que pode estar a alguns metros de distância do conjunto paciente, examinador e equipamento Bluetooth, surgiu a necessidade de um botão que solicitasse o armazenamento dos sons captados por parte do aplicativo em execução no computador. 

Para a implementação dessa funcionalidade, foi utilizada uma interrupção externa do client (\textbf{Módulo 3}), disparada pelo botão esquerdo do mesmo (podendo ser reconfigurado para qualquer pino de propósito geral da placa). Como esse módulo fica perto do paciente, é possível realizar a operação sem movimentação até o notebook ou até o server (\textbf{Módulo 4}).

%inserir foto do botão esquerdo

O fluxo de tratamento dessa interrupção para inicialização remota da gravação acontece da seguinte forma:

\begin{enumerate}
    \item O botão é pressionado no \textbf{Módulo 3} disparando uma interrupção externa.
    \item Essa interrupção externa faz com que seu tratador envie uma série de dados pré-definidos chamados de \textit{código de operação} via bluetooth para o \textbf{Módulo 4}.
    \item Esse código de operação é enviado pelo \textbf{Módulo 4} via USB ao notebook/microcomputador.
    \item No código do aplicativo presente notebook/microcomputador existe um loop que faz \textit{polling} dos dados recebidos do \textbf{Módulo 4}. Dentro desse loop, existe um código de tratamento que localiza o código recebido no fluxo de dados.
    \item Esse código de tratamento gera um evento que envia via \textbf{Módulo 4}, por bluetooth, um outro código de operação que é detectado pelo \textbf{Módulo 3}, inicializando a operação de transmissão e aquisição dos dados.
\end{enumerate}

O código em ambos \textbf{Módulo 3} e \textbf{Módulo 4} faz uso de um LED que fica aceso pela duração da transmissão, de forma a notificar o operador, evitando a movimentação até o notebook/microcomputador pelo usuário do sistema.

O código abaixo é uma cópia exata da execução do console do aplicativo desenvolvido após o botão esquerdo ser pressionado:

\begin{verbatim}
    $ python .\serial_reader.py
    $ Iniciando shell do estetoscópio
    $ >
    $ Código de operação recebido
    $ Inicializando aquisição e salvando dados
    $ Aquisição completa
\end{verbatim}

\section{Aprimoramentos Realizados}

Uma das propostas concebidas pelo orientador foi a integração de um acelerômetro e giroscópio, dispositivo que mede aceleração e posição absoluta, de forma a obter dados espaciais do tórax do paciente. A partir dessa proposta foi elaborada uma interface para a aquisição de dados de sensores que contém tanto acelerômetro quando giroscópio.

O periférico de giroscópio e acelerômetro escolhido foi o \texttt{MPU6050}. Seu baixo custo, alta precisão e plena disponibilidade oferecem um bom dispositivo. O \texttt{MPU6050} é conta com 6 \textit{ADCs}, cada um de 16 \textit{bits}. Cada um desses \textit{ADCs} é responsável pela digitalização de um eixo do acelerômetro ou do giroscópio embarcados na \textit{breakout board}. Também oferece um filtro passa-baixas digitalmente programável, descartando a necessidade de pós-processamento e baixo consumo (em torno de \textit{3.6mA} de acordo com a fabricante). 

\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.4]{MPU6050_pic.png}
    \caption{\texttt{MPU6050} \textit{breakout board}. Fonte: www.easytronics.com.br}
\end{figure}

O \texttt{MPU6050} possui um sistema simples de endereçamento, que permite endereçar até dois chips usando apenas um periférico \textit{i\textsuperscript{2}c}. Como a plataforma atual possui dois desses periférico (representados pelo Módulo 2.2, figura 2.1), é possível o endereçamento de até 4 combos de sensores de posição espacial. Qualquer pino pode ser reprogramado para funcionar como esse protocolo.

Abaixo são listados os parâmetros de configuração \textit{i\textsuperscript{2}c}.

    \begin{table}[H]
        \centering
        \begin{tabular}{|l|l|}
            \hline
            \textbf{Parâmetro}                    & \textbf{Valor} \\ \hline
            Modo de comunicação CC2640R2 & Mestre \\ \hline
            Modo de comunicação \texttt{MPU6050}  & Escravo \\ \hline
            Taxa do clock                & 400kHz \\ \hline
            Tamanho da Amostra           & 16 bits \\ \hline
        \end{tabular}
        \caption{Parâmetros de configuração \textit{i\textsuperscript{2}c}}
    \end{table}
    

A metodologia de programação desse periférico se deu no desenvolvimento de um {\textit{driver}} do mesmo, que abstraí rotinas de baixo nível do periférico via uma \textit{API}. Como no programa escrito em Python para recebimento dos dados pela serial, optamos por uma forte filosofia de portabilidade, escrevendo a biblioteca de uma maneira portável, podendo ser utilizada em outros microcontroladores e até outros projetos.

A taxa de aquisição desse sensor foi programada em função da taxa de aquisição do \textit{ADC}. A cada disparo do relógio, existe uma lógica de contador que divide esse clock afim de realizar a aquisição do acelerômetro + giroscópio. Dessa forma, a taxa de aquisição do acelerômetro + giroscópio nunca pode ser maior do que a do \textit{ADC}. De qualquer forma a taxa de 12MHz do \textit{ADC} é maior que a taxa de 1kHz do acelerômetro e 8kHz do giroscópio.


\chapter{RESULTADOS E DISCUSSÃO}
As condições para realização dos testes não foi propícia devido aos eventos externos ocorridos no ano de 2020, impossibilitando tanto contato quanto acesso aos equipamentos e profissionais necessários para continuar os trabalhos normalmente, dadas as questões sanitárias. De qualquer forma, houveram testes regulares em todas as partes do projeto, o que garante o funcionamento em ambiente de desenvolvimento. À exceção da aquisição de sinais de pacientes, todos os objetivos do projeto foram atingidos.

Dado que a forma de conexão dos equipamentos e seu hardware continuaram constantes na realização deste trabalho, a distância de operação entre os equipamentos é, de forma aparente, 10 a 5 metros, a mesma realizada por \cite{willian}.

O sistema sofre ainda, com falta de estabilidade em certos pontos da conexão. Um aumento nos tempos de atualização do Bluetooth já feitos no trabalho anterior mostraram uma melhora, apesar disso, quedas ainda existem. Se cogita que uma das possíveis soluções seja portar o projeto para utilizar uma versão mais nova do firmware distribuído pela fabricante, que conta com possível correção de bugs e ofereça maior estabilidade.

A falta de estabilidade geral do sistema também é ocasionada pela pouca memória volátil existente no sistema. O tamanho de pacote transmitido pelo protocolo sofreu aumento para acomodar os dados do giroscópio e acelerômetro, causando maior uso na memória volátil. 

Como o firmware escrito para os módulos foi realizado em nível alto e portável dentro da linha suportada pela fabricante, e o driver do acelerômetro e giroscópio também foi escrito com este escopo de portabilidade em mente, se sugere o uso de uma plataforma com maior memória volátil disponível, ou plataforma que possa fazer acesso de memória externa a unidade do microprocessador. A organização interna do código e arquitetura geral do firmware foi desenvolvida em torno da pouca memória volátil disponível. Visando a manutenção do código, uma programação mais orientada e seguindo de forma mais próxima a filosofia de Sistemas Operacionais também se beneficiaria com o aumento da quantidade de memória.

A principal motivação educacional nesse trabalho consistiu do estudo de ambientes de programação, plataformas profissionais de desenvolvimento, compiladores, e principalmente de Sistemas Operacionais em Tempo Real e programação paralela, que foi empregada em todos os níveis de desenvolvimento do sistema. Dentro de Sistemas Operacionais, a ênfase foi dada na depuração e resolução de problemas, essenciais no escopo prático de desenvolvimento.

O estudo também incluiu uma sólida introdução as camadas do protocolo Bluetooth, com exemplos práticos de como essa tecnologia pode ser empregada no desenvolvimento de sistemas embarcados, incluindo conhecimento de pontos fortes e limitações da tecnologia.


\addcontentsline{toc}{chapter}{REFERÊNCIAS} 
\printbibliography

\nocite{Stallman}
\nocite{Huang}
\label{sec:driver}

\end{document}