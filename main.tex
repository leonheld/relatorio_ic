\documentclass[11pt, a4paper]{report}
\usepackage[portuguese]{babel}
\usepackage{csquotes}
\usepackage{lipsum}
\usepackage{graphicx}
\usepackage{pdfpages}
\usepackage{hyperref}
\usepackage{textcomp}

\usepackage{listings}
\usepackage{indentfirst} %\section or \chapter by default don't indent the first paragraph for some absurd reason!

\usepackage[style=abnt]{biblatex}
\addbibresource{references.bib}        % Seus arquivos de

\begin{document}
\begin{titlepage}
    \begin{center}
        \vspace*{1cm}
        \Huge
        \textbf{Título}

        \vspace{0.5cm}
         Subtítulo
             
        \vspace{1.5cm}

        Relatório Final de \\
        pesquisa de Iniciação Científica
 
        \vfill
        \Large
        \textbf{Aluno: Leonardo José Held}\\
        \textbf{Orientador: Raimes Moraes}
        \vspace{0.8cm}

        Departamento de Engenharia Elétrica e Eletrônica\\
        Curso de Graduação em Engenharia Eletrônica\\
        Universidade Federal de Santa Catarina\\
        Brasil\\
        %TODO:
        
             
    \end{center}
 \end{titlepage}
 \Large

 \tableofcontents

\chapter{Resumo}




Palavras-chave: Instrumentação médica. Sistema respiratório. Sons respiratórios. Estetoscópio Eletrônico. Processamento Digital de Sinais.

\chapter{Introdução}

O diagnóstico prematuro correto de enfermidades respiratórias pode representar uma redução significativa de mortes. Nesse sentido, são utilizados métodos de asculta pulmonar, realizada rotineiramente por médicos treinados. Um ponto forte é o baixo custo, não possuindo necessidade de equipamentos proibitivamente caros e não invasivo, pois não exige movimentação excessiva de pacientes acamados. No entanto, o examinador pode ser impedido de executar o exame com acurácia devido à inexperiência e capacidade auditiva. Assim, surgiram estetoscópios eletrônicos de baixo custo, que podem captar e preparar sinais que podem ser processados via técnicas de análise, retirando a subjetividade e democratizando o acesso ao exame. Esse trabalho propõe o aprimoramento e expansão de um sistema de aquisição de sons respiratórios produzidos no LCS - UFSC. O módulo\cite{willian}, - que antes contava com receptor e transmissor \textit{Bluetooth 5.0}, e um periférico de aquisição de sinais analógicos - foi aprimorado com uma nova interface para sensor de posicionamento espacial.

\section{Objetivo}

O aprimoramento do sistema - referenciado na introdução deste capítulo -, tem como objetivo auxiliar o leque de informações disponíveis para processamento e próximas pesquisas nessa área. Em específico, informações sobre o posicionamento toráxico do paciente aliadas as informações extraídas dos sons pulmonares podem ajudar a mitigar fatores de erro no processamento desses mesmos dados.

\cite{Huang} sugere que a ascultação pulmonar pode ser usada para detecção antecipada de doenças como COVID-19, tornando estetoscópios eletrônicos ainda mais pertinentes pelas vantagens já citadas. 


\chapter{MATERIAL E MÉTODOS}


\section{Revisão bibliográfica}
\label{sec:review}

A tecnologia \textit{Bluetooth 5.0} é uma tecnologia definida por um grupo de trabalho denominado \textit{Bluetooth Special Interest Group}. Nesse, se define um padrão de comunicação sem fio entre dois - ou mais - dispositivos numa banda de frequência normalmente utilizada para fins industriais, científicos e médicos. Originalmente, o Bluetooth foi criado para estabelecer um tipo de comunicação simples, serial, que já existia na forma de conexão via cabo entre dispositivos.

De acordo com \cite{omre}, os principais pontos que fazem com que \textit{Bluetooth} sejam uma boa escolha meios médicos são: interoperabilidade, baixo consumo, customização de formato de transmissão (pacote), compatibilidade eletromagnética (equipamentos médicos coexistem, não podendo inteferir negativamente uns com os outros), segurança na transmissão para proteger confidencialidade da informação e hub de sensores (diversos equipamentos médicos precisam ser atualizados em tempo real via internet para fins de telemedicina). 

A necessidade de se utilizar uma tecnologia de ponta nesse projeto surge da grande quantidade de dados envolvidos na transferência de sons respiratórios. Na especificação do \textit{BLE} ou \textit{Bluetooth Low Energy}, um padrão de Bluetooth utilizado pelo baixo consumo, o \textit{throughput} é limitada em 2mpbs, porém, dado um \textit{overhead} utilizado por headers e dependente do hardware onde o protocolo está sendo executado, a velocidade efetiva de transmissão é geralmente menor do que a especificada.
 
Também é um protocolo aberto para implementação, realizado pelas principais empresas de tecnologia mundiais, fomentando os pontos de interoperabilidade de equipamentos e segurança. 

O sistema construído conta com uma interface para acelerômetro, giroscópio (\textbf{Módulo 2.2}) e um \textit{ADC} - \textit{Analog to Digital Converter}, Conversor Analógico-Digital - (\textbf{Módulo 2.1}). O acelerômetro + giroscópio é utilizado para obter informação espacial do tórax, e o Conversor Analógico-Digital é utilizado para obter sons respiratórios via uma interface de transdutores (\textbf{Módulo 1}).

Também conta com um programa escrito em Python que obtém os dados recebidos pelo USB - via serial - do módulo de recepção dos dados, denominado \textbf{Módulo 4}, que são enviados pelo módulo de amostragem, ou \textbf{Módulo 3}.

\begin{center}
    \includegraphics[width=0.9\textwidth]{esquematico_novo.png}\\
    \footnotesize{Fonte: O autor.}
\end{center}

%todo: citar aqui certinho a interface

Dado o problema de aquisição de dados em períodos de tempo rígido, existe a necessidade de uso de um Sistema Operacional em Tempo Real rodando em ambos módulos de amostragem e recepção dos dados. 

De acordo com \cite{freertos} um Sistema Operacional em Tempo Real como um sistema que precisa saber o tempo de término quão mais exato de uma tarefa. Ou seja, um sistema em tempo real se carateriza pelo caráter determínistico. É ideal para aplicações onde ações externas precisam ser induzidas em intervalos de tempo regulares e extremamente corretos, como aquisição de som, no nosso caso, ou o disparo de um air-bag. 

Ambos módulos de Amostragem e Recepção dos dados são placas de desenvolvimento da \textit{Texas Instruments}\textsuperscript{\textregistered}, codenome \texttt{LAUCHPAD-XL} contendo o chip \textit{CC2640R2} e que suportam a tecnologia \textit{BLE 5.0}, \textit{Bluetooth Low Energy 5.0}. 

Ademais, a empresa disponibiliza juntamente com as placas um Sistema Operacional em Tempo Real denominado \texttt{TIRTOS} juntamente com um kit de desenvolvimento (SDK). Por estes, fazemos uso das facilidades do hardware de Bluetooth que existem nessa plataforma.

\label{sec:hardware}
\section{Características de módulos microcontrolados com capacidades \textit{BLE 5.0}}

\begin{center}
    \includegraphics[width=2.8\textwidth]{soc.jpg}\\
    \footnotesize{Fonte: Texas Instruments\textsuperscript{\textregistered}}
\end{center}

Observando o esquemático de blocos do \textit{SoC}, vemos que o mesmo conta com um processador ARM Cortex-M3 e ARM Cortex-M0. O primeiro serve de processador de propósito geral, e é extendido para os pinos de entrada e saída (\textit{I/O}) de cada placa. O segundo é um processador de propósito específico que contém código que controla o circuito de radiofrequência (\textit{RF}) responsável pela implementação do protocolo \textit{Bluetooth} da placa. 

Existe um protocolo de comunicação não-acessível pelo usuário da placa entre os dois processadores que serve para aquisição e envio de mensagens pelo Bluetooth. Fazemos uso, então, do \textit{Cortex-M3} para acessar e obter dados dos sensores ou periféricos. Estes, por sua vez, são enviados via para a segunda \textit{CC2640R2} usando a API da \textit{TI}.
 %TODO: Referência do documento da API da TI

 Algumas limitações de hardware ainda são realidade para essa tecnologia, fato que, por extensão, limita a escolha de placas de desenvolvimento no mercado. A tecnologia \textit{BLE 5.0}, por mais que o protocolo da presente versão tenha sido homologado em 2016, ainda não é totalmente adotada e nem amplamente utilizada por vários dispositivos. Visto que o ecossistema do projeto já estava baseado na \texttt{LAUCHPAD-XL}, o projeto ali se deu prosseguimento.



%TODO: Inserir figura da launchpad

\section{Estudo de ambientes de programação, Sistema Operacional e exemplos de fabricante}

A \textit{TI} disponibiliza, em termos, o TIRTOS, um Sistema Operacional em Tempo Real (a partir daqui denominado como RTOS, ou \textit{Real Time Operating System}, \textit{Sistema Operacional em Tempo Real}, em tradução livre). Tal RTOS é uma peça de software capaz de gerenciar de forma inteligente, levando em consideração questões de tempo, rotinas e procedimentos escritos em linguagem de programação\cite{tirtosguide}. A empresa, no entanto, não disponibiliza o código aberto de tal RTOS, mas sim uma \textit{API - Application Programming Interface}, que permite seu uso. Essa \textit{API} contém \textit{drivers}, ou camadas de abstração entre o código e o uso do hardware. Por exemplo, um driver de timer para controlar ciclos de tempo, ou um driver de periférico como \textit{SPI}.

O princípio de funcionamento básico de um RTOS é fazer com que várias rotinas (também chamadas de funções) possam ser executadas em \textit{quasi-}paralelismo. Ou seja, eficientemente alocando tempo de execução de código em um único processador para concluir várias tarefas diferentes, criando uma ilusão de paralelismo entre as mesmas. Além, a parte de "Tempo Real" se refere aos padrões rígidos que o sistema impõe para execução de tarefas.

Tais sistemas são de suma importância para diversas aplicações na indústria e na ciência, sendo exaustivamente utilizado em diversos setores, como robótica, equipamentos biomédicos e quaisquer sistemas sensíveis a requerimentos de tempo.

A empresa também disponibiliza exemplos de aplicação que podem ser extendidos e modificados livremente, sob licença aberta. Um desses é o \textit{Simple Port Profile}, de nome homônimo ao padrão apresentado na seção \hyperref[sec:review]{3.1}, que é um simples firmware que conecta duas plataformas \textit{CC2640} e transfere texto numa configuração half-duplex (bidirecional, não simultâneo) entre as duas. 

Esse exemplo foi compilado, estudado e analisado, visando compreendimento base do Sistema Operacional. O projeto também usa esse exemplo de aplicação como projeto-base.

\section{Desenvolvimento de firmware para testes de sinais simulados de aúdio}

A partir disso, foram iniciados estudos sobre como o sistema de aquisição e transmissão criado por \cite{willian}. Durante esse passo, notamos as limitações promovidas pela construção e configuração padrão do hardware da plataforma \textit{CC2640R2}. 

O principal esforço se deu a trabalhar dentro de limitações extremas de memória volátil (memória não persistente). Com apenas 8\texttt{kb} de memória do tipo volátil, sendo que o Sistema Operacional em uso pode ocupar cerca de $25\%$ desse valor, fazendo com que inserção de rotinas novas necessitem de cuidado para evitar possíveis \textit{overflows}, ou estouro de memória por sua insuficiência.

O sistema conta com um \textit{ADC} de 16 \textit{bits} de dois canais modelo \textit{LTC1867LCGN} da \textit{Linear Devices\textsuperscript{\textregistered}}. Este se conecta a uma front-end desenvolvida por [trabalho que desenvolveu a frontend]

\begin{center}
    \includegraphics[width=0.7\textwidth]{estetoscopio.jpg}\\
    \footnotesize{Fonte: \cite{willian}}
\end{center}

O projeto pode ser utilizado para se obter sinais de  com pouca interferência e distúrbio para pacientes. Os sinais podem, \textit{a posteriori} ser processados e analisados por técnicas específicas de processamento de sinal. A interface também pode ser vista como um estetoscópio eletrônico de baixo custo e performance comparável aos dispositivos existentes no mercado, que são de código fechado e valor proibitivo para uma grande parcela de possíveis aplicações.

A comunicação \textit{ADC} \textrightarrow \textit{CC2640} é realizada pelo padrão \textit{SPI}, tal como citado na seção \hyperref[sec:review]{2.1} com as seguintes configurações:

%TODO: Inserir aqui figura (na real montar um tabular que fica mais limpo) das configurações da SPI. 12MHz e tal e tal

    \begin{table}[]
        \centering
            \begin{tabular}{|l|l|}
            \hline
            \textbf{Parâmetro}                    & \textbf{Valor} \\ \hline
            Modo de comunicação CC2640R2 & Mestre \\ \hline
            Modo de comunicação LTC1867L & Escravo \\ \hline
            Taxa do clock                & 12MHz \\ \hline
            Tamanho da Amostra           & 16 bits \\ \hline
            CPOL (Clock Polarity)        & 0 \\ \hline
            CPHA (Clock Phase)           & 0 \\ \hline
            Modo                         & Callback \\ \hline
        \end{tabular}
    \end{table}
            
Foram corrigidos avisos gerados por conversões digitais implícitas que existiam nos valores amostrados do \textit{ADC} quando levadas ao buffer de transmissão utilizado pelo projeto.

Para disparar a aquisição desse periférico é utilizado um relógio em modo periódico que faz a requisição dos sinais a cada $100\mu s$.

O sistema foi então testado com sinais alternados tanto gerados pelo próprio microcontrolador quanto externos e obteve resposta satisfatória.


\section{Desenvolvimento de Aplicativo para Notebook}

O projeto original também conta com um aplicativo para Notebooks e Computadores Windows, que captura os pacotes transmitidos via Bluetooth pelo \textit{Client} do sistema por emulação de porta serial via USB. O primeiro problema foi a falta de documentação sobre o projeto, que não provinha de instruções de compilação. As bibliotecas utilizadas no projeto também eram de versões antigas, com diversos problemas de interoperabilidade. 

Ultrapassando o problema de compilação do projeto, percebemos que o mesmo utilizada a \textit{API} do próprio sistema Windows NT. O código utilizado para acesso ao periférico da porta serial emulada sobre USB era datado, não se comportando bem em novas versões do sistema Windows NT. Decidimos então criar um novo programa que capture as informações de quaisquer porta serial, com a necessidade de fácil manutenção e pouca modificação entre sistemas operacionais host. Dessa forma, foi escrito um programa na linguagem de programação Python que obtém os dados da porta serial e os salva para pós-processamento, que mostrou bom desempenho. Se necessário, métodos de pós-processamento podem ser programados de maneira não obtusa no programa, gerando os dados de maneira rápida.

\subsection{Código para atendimento de interrupção externa}

Considerando que acessar o equipamento notebook que pode estar a alguns metros de distância do conjunto paciente, examinador e equipamento Bluetooth, surgiu a necessidade de um botão que dispare o programa de computador supracitado. 

Uma modificação simples foi um algoritmo de \textit{poooling} - ou espera - de inicialização remota da gravação, em conjunto com uma modificação que não custou a já escassa memória de dados das placas. Aumentando o conforto do uso em pacientes com dificuldade de locomoção. 

Quando um botão é pressionado no Client, o mesmo envia uma curta mensagem de 8 bytes para o Server. O Server é conectado via cabo USB ao Notebook. Quando o Notebook detecta essa mensagem, ele envia uma mensagem ao Client pelo Server para que se comece a inicialização da aquisição e ao mesmo tempo começa a gravação dos dados recebidos pelo Server. 

\section{Testes e aprimoramento do Sistema Desenvolvido}

Uma das propostas concebidas pelo orientador foi a integração de um acelerômetro e giroscópio, dispositivo que mede aceleração e posição absoluta, de forma a obter dados espaciais do tórax do paciente. A partir dessa proposta foi elaborado uma interface parar aquisição de dados de pequenos sensores que contém tanto acelerômetro quando giroscópio.

O periférico de giroscópio e acelerômetro escolhido foi o \textit{MPU6050}. Seu baixo custo, alta precisão e plena disponibilidade oferecem um bom dispositivo. O \textit{MPU6050} é conta com 6 \textit{ADCs}, cada um de 16 \textit{bits}. Cada um desses \textit{ADCs} é responsável pela digitalização de um eixo do acelerômetro ou do giroscópio embarcados na \textit{breakout board}. Também oferece um filtro passa-baixas digitalmente programável, descartando a necessidade de pós-processamento e baixo consumo (em torno de \textit{3.6mA} de acordo com a fabricante). 

Nossa expansão incluiu o módulo de acelerômetro e giroscópio \textit{MPU6050}, o que possibilita a captação de sinais de posição em três dimensões com \textit{n}-graus de liberdade, onde \textit{n} é o número de sensores acelerômetro e giroscópio disponíveis no sistema. Claramente existe um limite no número de sensores dado as limitações de memória e hardware disponíveis no sistema. Em específico, o MPU6050 possui um sistema simples de endereçamento, que permite endereçar até dois chips usando apenas um periférico \textit{i\textsuperscript{2}c}. Como a plataforma atual possui dois desses periférico, é possível o endereçamento de até 4 combos de sensores de posição espacial. Qualquer pino pode ser reprogramado para funcionar como esse protocolo.

Abaixo são listados os parâmetros de configuração \textit{i\textsuperscript{2}c}.

    \begin{table}[]
        \centering
        \begin{tabular}{|l|l|}
            \hline
            \textbf{Parâmetro}                    & \textbf{Valor} \\ \hline
            Modo de comunicação CC2640R2 & Mestre \\ \hline
            Modo de comunicação MPU6050  & Escravo \\ \hline
            Taxa do clock                & 400kHz \\ \hline
            Tamanho da Amostra           & 16 bits \\ \hline
        \end{tabular}
    \end{table}
    

A metodologia de programação desse periférico se deu no desenvolvimento de um \hyperref[sec:driver]{\textit{driver}} do mesmo, que abstraí rotinas de baixo nível do periférico via uma \textit{API}. Como no programa escrito em Python para recebimento dos dados pela serial, optamos por uma forte filosofia de portabilidade, escrevendo a biblioteca de uma maneira portável e agnóstica à plataforma, podendo ser utilizada em outros microcontroladores e até outros projetos.

A taxa de aquisição desse sensor foi programada em função da taxa de aquisição do \textit{ADC}. A cada disparo do relógio, existe uma simples lógica de contador que divide esse clock afim de realizar a aquisição do acelerômetro + giroscópio. Dessa forma, a taxa de aquisição do acelerômetro + giroscópio nunca pode ser maior do que a do \textit{ADC}. De qualquer forma a taxa de 12MHz do \textit{ADC} é maior que a taxa de 1KHz do acelerômetro e 8KHz do giroscópio.


\chapter{RESULTADOS E DISCUSSÃO}
As condições para realização dos testes não foi propícia devido aos eventos externos ocorridos no ano de 2020, impossibilitando tanto contato quanto acesso aos equipamentos e profissionais necessários para continuar os trabalhos normalmente, dadas as questões sanitárias. De qualquer forma, houveram testes regulares em todas as partes do projeto, o que garante o funcionamento em ambiente de desenvolvimento.
 
Ademais, a natureza de dispositivos embarcados é de baixo consumo e baixo processamento. Logo, a maior dificuldade em todas as etapas do projeto foi fazer uma alta manutenção de RAM (memória volátil). Ainda sim, a plataforma escolhida pode permitir comutações de código entre processadores e famílias de dispositivos, permitindo fácil portabilidade para microcontroladores com maior capacidade que venham a ser lançados suportando BLE 5.0.

\addcontentsline{toc}{chapter}{REFERÊNCIAS} 
\printbibliography

\chapter*{Interface do Driver MPU6050}
\addcontentsline{toc}{chapter}{Interface do Driver MPU6050}
\nocite{Stallman}
\nocite{Huang}
\label{sec:driver}
\lstset{basicstyle=\normalsize}
\lstinputlisting{mpu6050.c}

\end{document}