\documentclass[11pt, a4paper]{report}
\usepackage[portuguese]{babel}
\usepackage{csquotes}
\usepackage{lipsum}
\usepackage{graphicx}
\usepackage{pdfpages}
\usepackage{hyperref}
\usepackage{textcomp}
\usepackage{float}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric}

\usepackage{listings}
\usepackage{indentfirst} %\section or \chapter by default don't indent the first paragraph for some absurd reason!

\usepackage[style=abnt]{biblatex}
\addbibresource{references.bib}        % Seus arquivos de

\begin{document}
\begin{titlepage}
    \begin{center}
        \vspace*{1cm}
        \Huge
        \textbf{Título}

        \vspace{0.5cm}
         Subtítulo
             
        \vspace{1.5cm}

        Relatório Final de \\
        pesquisa de Iniciação Científica
 
        \vfill
        \Large
        \textbf{Aluno: Leonardo José Held}\\
        \textbf{Orientador: Raimes Moraes}
        \vspace{0.8cm}

        Departamento de Engenharia Elétrica e Eletrônica\\
        Curso de Graduação em Engenharia Eletrônica\\
        Universidade Federal de Santa Catarina\\
        Brasil\\
        %TODO:
        
             
    \end{center}
 \end{titlepage}
 \Large

 \tableofcontents

\chapter{Resumo}

Entre os diversos métodos de diagnóstico de enfermidades pulmonares, a asculta de sons respiratórios sobre o toráx tem como vantagens o fato de ser  não invasivo e ter baixo custo 
%adicionar referência
cite{carvalho}. No entanto, devido à fatores técnicos como qualidade do estetoscópio, acurácia auditiva do examinador e atenuação do som pelo toráx do paciente, além da subjetividade pelo fator humano envolvido no exame, há esforços para tornar este método mais robusto, proporcionando um diagnóstico mais confiável. Este trabalho tem como objetivo aperfeiçoar estetoscópio eletrônico desenvolvido neste laboratório que digitaliza e transmite sons respiratórios, bem como, registra o deslocamento do tórax para identificação da fase respiratória. O sistema consiste de dois módulos transmissor e receptor, que respectivamente amostram e recebem o som em um microcomputador pessoal para armazenar os sons captados de pacientes. O protocolo de transmissão utilizado é o \textit{Bluetooth 5.0}. Neste trabalho, são reportados o estudo, teste e o aprimoramento do sistema.


Palavras-chave: Instrumentação médica. Sistema respiratório. Sons respiratórios. Estetoscópio Eletrônico. Processamento Digital de Sinais.

\chapter{Introdução}

O prematuro diagnóstico de enfermidades respiratórias pode representar uma redução significativa de óbitos. Dentre os métodos de diagnóstico, tem-se a asculta pulmonar, rotineiramente realizada  por médicos treinados. Seus pontos fortes são o baixo custo e o baixo tempo de resposta,  não demandando  o deslocamento de pacientes acamados para salas de exames. No entanto, o diagnóstico é fortemente dependente da experiência e capacidade auditiva do examinador. Neste contexto, surgiram estetoscópios eletrônicos de baixo custo que podem captar e registrar sinais que podem ser digitalmente processados com o objetivo de prover indíces quantitativos para orientar o diagnóstico, de tal forma a tornar o diagnóstico menos subjetivo e permitir a troca de informações entre especialistas. Esse trabalho propõe o aprimoramento com integração de funcionalidade adicionais a  um sistema de aquisição de sons respiratórios desenvolvido no LCS - UFSC. O módulo desenvolvido por \cite{willian}, - que antes contava com receptor e transmissor \textit{Bluetooth 5.0}, e um periférico de aquisição de sinais analógicos - foi aprimorado com a integração de sensor para registro da fase respiratória.

\section{Objetivo}

Esse trabalho objetivou o aprimoramento de sistema de captação de sons respiratórios anteriormente desenvolvido, adequando-o para a aquisição de sons respiratórios em ambiente hospitalar.

Como desenvolvimento adicional, acrescentou-se sensor para registrar deslocamento da parede torácica para identificar a fase respiratória. 

\chapter{MATERIAL E MÉTODOS}


\section{Introdução}

%TODO: Consertar essa figura. Não fica bonito ter a figura sem texto antes, mas ela não cabe no restante da página. Se deixar muito pequena fica pouco legível.
\begin{center}
    \includegraphics[width=0.9\textwidth]{esquematico_novo.png}\\
    \footnotesize{Fonte: O autor.}
\end{center}

A Figura 1 apresenta o diagrama em blocos do sistema desenvolvido em trabalho anterior \cite{willian}, no qual se incluiu um interface para acelerômetro e giroscópio.

O sistema possui módulo para a captação de sons respiratórios (módulo 1), firmware dos módulos de amostragem, transmissão e recepção de dados (módulos 3 e 4), bem como de aplicativo para sistema operacional Windows (módulo 5). Este aplicativo objetiva a apresentação, armazenamento e reprodução das formas de onda amostradas. O aplicativo conta com programa escrito em Python (desenvolvido neste trabalho) que obtém os dados recebidos pela USB - via serial - do módulo de recepção dos dados, denominado \textbf{Módulo 4}, que são enviados pelo módulo de amostragem, ou \textbf{Módulo 3}.Cada um destes módulos é detalhado nas subseções seguintes.

O módulo 3 (Figura 1) controla a digitalização dos sinais do ADC via interface SPI, empacota as amostras e os transmite por radiofrequência (Bluetooth) para o módulo de recepção (módulo 4).  Estas etapas são realizadas por meio do kit de desenvolvimento BLE da Texas Instruments (CC2640R2F \texttt{LAUNCHPAD-XL Kit}). Este kit com protocolo Bluetooth 5 proporciona uma considerável redução no tempo de desenvolvimento da solução BLE, oferecendo taxa de transmissão e consumo de energia que atendem às necessidades do projeto. 

A transmissão por tecnologia \textit{Bluetooth} em sua versão 5.0 foi selecionada devido a larga banda dados que devem ser transmitidos, visto que os sons respiratórios gravados são de alta fidelidade, e transmitidos sem compressão.

O dispositivo \texttt{LAUNCHPAD-XL Kit} baseia-se em processador ARM® Cortex®-M3 que gerencia a camada de aplicação e a pilha de protocolos BLE. Além disso, possui um sistema autônomo de rádio (utilizando um processador ARM Cortex®-M0) que gerencia todo o controle e processamento das camadas inferiores associadas à camada física e partes da camada de enlace. 
Para administrar todo este conjunto de tarefas, o módulo \texttt{LAUNCHPAD-XL Kit} utiliza um sistema operacional em tempo real proprietário da Texas Instruments (TIRTOS).
Para melhor compreensão do sistema existente, este trabalho foi iniciado com o estudo do protocolo Bluetooth e o TIRTOS.


\label{sec:hardware}
\section{Características de módulos microcontrolados com capacidades \textit{BLE 5.0}}


Ambos módulos de Amostragem e Recepção (módulos 3 e 4, respectivamente na figura 1, seção 3.1) dos dados são placas de desenvolvimento da \textit{Texas Instruments}\textsuperscript{\textregistered}, codenome \texttt{LAUNCHPAD-XL-XL} contendo o chip \textit{CC2640R2} e que suportam a tecnologia \textit{BLE 5.0}, \textit{Bluetooth Low Energy 5.0}.

\begin{center}
    \includegraphics[width=0.4\textwidth]{cc2640r2.jpg}\\
    \footnotesize{Fonte: Texas Instruments\textsuperscript{\textregistered}}
\end{center}

A figura a seguir mostra o esquemático funcional de blocos dos módulos 3 e 4, que como mencionado na introdução deste trabalho, são plataformas de desenvolvimento \textit{CC2640R2}.

\begin{center}
    \includegraphics[width=2.6\textwidth]{soc.jpg}\\
    \footnotesize{Fonte: Texas Instruments\textsuperscript{\textregistered}}
\end{center}

Observando o esquemático dos módulos, vemos que o mesmo conta com um processador ARM Cortex-M3 e ARM Cortex-M0. O primeiro serve de processador de propósito geral, e é extendido para os pinos de entrada e saída (\textit{I/O}) de cada placa. O segundo é um processador de propósito específico que contém código que controla o circuito de radiofrequência (\textit{RF}) responsável pela implementação do protocolo \textit{Bluetooth} da placa. 

Existe um protocolo de comunicação não-acessível pelo usuário da placa entre os dois processadores que serve para aquisição e envio de mensagens pelo Bluetooth. Fazemos uso, então, do \textit{Cortex-M3} para acessar e obter dados dos sensores ou periféricos. Estes, por sua vez, são enviados via para a segunda \textit{CC2640R2} usando a API da \textit{TI}.
 %TODO: Referência do documento da API da TI

 Algumas limitações de hardware ainda são realidade para essa tecnologia, fato que, por extensão, limita a escolha de placas de desenvolvimento no mercado. A tecnologia \textit{BLE 5.0}, por mais que o protocolo da presente versão tenha sido homologado em 2016, ainda não é totalmente adotada e nem amplamente utilizada por vários dispositivos. Visto que o ecossistema do projeto já estava baseado na \texttt{LAUCHPAD-XL}, o projeto ali se deu prosseguimento.

 \subsection{Bluetooth}
 O \textit{Bluetooth 5.0} é uma tecnologia definida por um grupo de trabalho denominado \textit{Bluetooth Special Interest Group}\cite{SIG}. Nesse, se define um padrão de comunicação sem fio entre dois - ou mais - dispositivos numa banda de frequência normalmente utilizada para fins industriais, científicos e médicos. Originalmente, o Bluetooth foi criado para estabelecer um tipo de comunicação simples, serial, que já existia na forma de conexão via cabo entre dispositivos.
 
 De acordo com \cite{omre}, os principais pontos que fazem com que \textit{Bluetooth} sejam uma boa escolha meios médicos são: interoperabilidade, baixo consumo, customização de formato de transmissão (pacote), compatibilidade eletromagnética (equipamentos médicos coexistem, não podendo inteferir negativamente uns com os outros), segurança na transmissão para proteger confidencialidade da informação e hub de sensores (diversos equipamentos médicos precisam ser atualizados em tempo real via internet para fins de telemedicina). 
 
 A necessidade de se utilizar uma tecnologia de ponta nesse projeto surge da já mencionada grande quantidade de dados envolvidos na transferência de sons respiratórios. Na especificação do \textit{BLE} ou \textit{Bluetooth Low Energy}, um padrão de Bluetooth utilizado pelo baixo consumo, com alcance de até 350 metros, o \textit{throughput} é limitada em 2Mpbs\cite{Panwar}, porém, dado um \textit{overhead} dependente do hardware onde o protocolo está sendo executado, a velocidade efetiva de transmissão é geralmente menor do que a especificada.
  
 Também é um protocolo aberto para implementação, realizado pelas principais empresas de tecnologia mundiais, fomentando os pontos de interoperabilidade de equipamentos e segurança. 

%todo: citar aqui certinho a interface
\subsection{Sistemas Operacionais em Tempo Real}

Dado o problema de aquisição de dados em períodos de tempo rígido, existe a necessidade de uso de um Sistema Operacional em Tempo Real rodando em ambos módulos de amostragem e recepção dos dados. 

De acordo com \cite{freertos} um Sistema Operacional em Tempo Real como um sistema que precisa saber o tempo de término quão mais exato de uma tarefa. Ou seja, um sistema em tempo real se carateriza pelo caráter determínistico. É ideal para aplicações onde ações externas precisam ser induzidas em intervalos de tempo regulares e extremamente corretos, como aquisição de som - no caso de estudo deste trabalho - ou o disparo de um air-bag.

O princípio de funcionamento básico de um RTOS é fazer com que várias rotinas (também chamadas de funções) possam ser executadas em \textit{quasi-}paralelismo. Ou seja, eficientemente alocando tempo de execução de código em um único processador para concluir várias tarefas diferentes, criando uma ilusão de paralelismo entre as mesmas. Além, a parte de "Tempo Real" se refere aos padrões rígidos que o sistema impõe para execução de tarefas \cite{tanenbaum}.

A principal estrutura de dados de um Sistema Operacional é o de \textit{Task}, \textit{Tarefa} ou \textit{Thread}. É uma estrutura contendo:

\begin{enumerate}
    \item A rotina (ou função) que deverá ser executada.
    \item Metadados sobre que acompanham a rotina. Estes são o modo atual de execução da rotina, sua prioridade e tamanho de memória disponível para o uso da rotina.
  \end{enumerate}

  Os metadados sobre a execução de uma tarefa, chamados de estado de execução mudam durante a execução da tarefa e podem ser \texttt{READY, RUNNING, BLOCKED} ou \texttt{TERMINATED}. A passagem de um estado para outro é sempre igual, e compõe a "vida de execução" de uma tarefa \cite{tirtosguide}. 

Na figura abaixo é possível observar a vida de execução de uma tarefa.

\begin{center}
    \includegraphics[width=1\textwidth]{task_execution.PNG}\\
    \footnotesize{Fonte: Texas Instruments}
\end{center}

Existem três blocos conceituais dentro de um Sistema Operacional: O \textit{Kernel}, \textit{User Space} e os \textit{Middleware}. Essa divisão se objetiva por segregar a memória, afim de manter segurança na execução de aplicações \cite{tanenbaum}.

O Kernel é a parte que tem controle total sobre o sistema, possuindo acesso irrestrito à memória do sistema, sendo responsável pelo controle das interações entre software e hardware, alocando recursos e executando tarefas.

O \textit{User Space} carateriza a parte da memória onde programas de usuário podem ser escritos, e podemos acessar funcionalidades do hardware via uma textit{API - Application Programming Interface}. Essa API configura um exemplo de \textit{Middleware}. Outros tipos de middleware pode ser códigos relacionados com conectividade (Bluetooth, TCP/IP), sistemas de arquivo ou gerenciamento de energia dos módulos embarcados.

\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.15]{os_esquematico.png}
    \caption{Fonte: O Autor}
\end{figure} 

O programa que realiza a funcionalidade de \textit{quasi-}paralelismo num RTOS é o escalonador, que reside no Kernel. A função principal do escalonador é criar uma fila das tarefas disponíveis escritas pelo programador e garantir que estas possam ser executadas dentro de um tempo limite chamado de \textit{time-slice} (na ordem de microssegundos). O escalonador pode ser observado, essencialmente, como um algoritmo de organização que minimiza o tempo de execução levando em consideração os metadados de cada tarefa\cite{tanenbaum}.

Para garantir que cada tarefa possa ser executada dentro do \textit{time-slice}, o escalonador pode dinamicamente fazer a \textit{preempção} de quaisquer tarefa por outra. Ou seja, se uma tarefa está sendo executada (modo de execução \texttt{RUNNING)}, o escalonador pode parar a execução da mesma se 

\begin{itemize}
    \item Seu \textit{time-slice} tiver acabado ou
    \item Exista outra tarefa de prioridade mais alta que esteja no estado \texttt{READY}.
  \end{itemize}

Tais sistemas são de suma importância para diversas aplicações na indústria e na ciência, sendo exaustivamente utilizado em diversos setores, como robótica, equipamentos biomédicos e quaisquer sistemas sensíveis a requerimentos de tempo. O compreendimento desses mecanismos são essenciais para a programação do ambos firmware dos módulos de recepção e amostragem.

Ademais, a Texas Instruments disponibiliza juntamente com os \texttt{LAUCHPAD-XL} um Sistema Operacional em Tempo Real denominado \texttt{TIRTOS} juntamente com um kit de desenvolvimento (SDK), este último contendo um Middleware que possibilita a utilização do protocolo Bluetooth na programação das placas. Por estes, fazemos uso das facilidades do hardware de Bluetooth que existem nessa plataforma. A empresa, no entanto, não disponibiliza o código aberto de tal RTOS, mas sim uma API, que permite seu uso \cite{tirtosguide}.

Entre essas APIs, existem drivers de periféricos (como SPI, timers e pinos de propósito geral), mecanismos de criação de tarefas e sistemas de gerenciamento de energia das placas.

A empresa também disponibiliza uma \textit{IDE - Integrated Development Environment}, ou Ambiente Integrado de Desenvolvimento chamado \texttt{Code Composer}. Esse ambiente contém um editor de texto, compilador, depurador e várias ferramentas de análise em tempo real para diversas plataformas.

Por esse ambiente, também são disponibilizados exemplos de aplicação que podem ser extendidos e modificados livremente, sob licença aberta. Um desses é o \textit{Simple Port Profile}, que é um simples firmware que conecta duas placas de desenvolvimento \textit{LAUNCHPAD-XL} e transfere bits numa configuração bidirecional entre as duas.

Esse exemplo foi compilado, estudado e analisado, visando compreendimento base do Sistema Operacional. O projeto também usa este exemplo de aplicação como projeto-base.

\section{Desenvolvimento de firmware para testes de sinais simulados de aúdio}

A partir disso, foram iniciados estudos sobre como o sistema de aquisição e transmissão criado por \cite{willian}. Durante este passo, notamos as limitações promovidas pela construção e configuração padrão do hardware da plataforma \textit{CC2640R2}. 

O principal esforço se deu a trabalhar dentro de limitações extremas de memória volátil (memória não persistente). Com apenas 8\texttt{kb} de memória do tipo volátil, sendo que o Sistema Operacional em uso pode ocupar cerca de $25\%$ desse valor, fazendo com que inserção de rotinas novas necessitem de cuidado para evitar possíveis \textit{overflows}, ou estouro de memória por sua insuficiência.

O sistema conta com um \textit{ADC} de 16 \textit{bits} de dois canais modelo \textit{LTC1867LCGN} da \textit{Linear Devices\textsuperscript{\textregistered}}. Esse se conecta a uma front-end desenvolvida por [trabalho que desenvolveu a frontend]

\begin{center}
    \includegraphics[width=0.7\textwidth]{estetoscopio.jpg}\\
    \footnotesize{Fonte: \cite{willian}}
\end{center}

O projeto pode ser utilizado para se obter sinais de  com pouca interferência e distúrbio para pacientes. Os sinais podem, \textit{a posteriori} ser processados e analisados por técnicas específicas de processamento de sinal. A interface também pode ser vista como um estetoscópio eletrônico de baixo custo e performance comparável aos dispositivos existentes no mercado, que são de código fechado e valor proibitivo para uma grande parcela de possíveis aplicações.

A comunicação \textit{ADC} \textrightarrow \textit{CC2640} é realizada pelo padrão \textit{SPI}, tal como citado na seção \hyperref[sec:review]{2.1} com as seguintes configurações:

%TODO: Inserir aqui figura (na real montar um tabular que fica mais limpo) das configurações da SPI. 12MHz e tal e tal

    \begin{table}[ht]
        \centering
            \begin{tabular}{|l|l|}
            \hline
            \textbf{Parâmetro}                    & \textbf{Valor} \\ \hline
            Modo de comunicação CC2640R2 & Mestre \\ \hline
            Modo de comunicação LTC1867L & Escravo \\ \hline
            Taxa do clock                & 12MHz \\ \hline
            Tamanho da Amostra           & 16 bits \\ \hline
            CPOL (Clock Polarity)        & 0 \\ \hline
            CPHA (Clock Phase)           & 0 \\ \hline
            Modo                         & Callback \\ \hline
        \end{tabular}
    \end{table}
            
Foram corrigidos avisos gerados por conversões digitais implícitas que existiam nos valores amostrados do \textit{ADC} quando levadas ao buffer de transmissão utilizado pelo projeto.

Para disparar a aquisição desse periférico é utilizado um relógio em modo periódico que faz a requisição dos sinais a cada $100\mu s$.

O sistema foi então testado com sinais alternados tanto gerados pelo próprio microcontrolador quanto externos e obteve resposta satisfatória.


\section{Desenvolvimento de Aplicativo para Notebook}

O projeto original também conta com um aplicativo para Notebooks e Computadores Windows, que captura os pacotes transmitidos via Bluetooth pelo \textit{Client} do sistema por emulação de porta serial via USB. O primeiro problema foi a falta de documentação sobre o projeto, que não provinha de instruções de compilação. As bibliotecas utilizadas no projeto também eram de versões antigas, com diversos problemas de interoperabilidade. 

Ultrapassando o problema de compilação do projeto, percebemos que o mesmo utilizada a \textit{API} do próprio sistema Windows NT. O código utilizado para acesso ao periférico da porta serial emulada sobre USB era datado, não se comportando bem em novas versões do sistema Windows NT. Decidimos então criar um novo programa que capture as informações de quaisquer porta serial, com a necessidade de fácil manutenção e pouca modificação entre sistemas operacionais host. Dessa forma, foi escrito um programa na linguagem de programação Python que obtém os dados da porta serial e os salva para pós-processamento, que mostrou bom desempenho. Se necessário, métodos de pós-processamento podem ser programados de maneira não obtusa no programa, gerando os dados de maneira rápida.

\subsection{Código para atendimento de interrupção externa}

Considerando que acessar o equipamento notebook que pode estar a alguns metros de distância do conjunto paciente, examinador e equipamento Bluetooth, surgiu a necessidade de um botão que dispare o programa de computador supracitado. 

Uma modificação simples foi um algoritmo de \textit{poooling} - ou espera - de inicialização remota da gravação, em conjunto com uma modificação que não custou a já escassa memória de dados das placas. Aumentando o conforto do uso em pacientes com dificuldade de locomoção. 

Quando um botão é pressionado no Client, o mesmo envia uma curta mensagem de 8 bytes para o Server. O Server é conectado via cabo USB ao Notebook. Quando o Notebook detecta essa mensagem, ele envia uma mensagem ao Client pelo Server para que se comece a inicialização da aquisição e ao mesmo tempo começa a gravação dos dados recebidos pelo Server. 

\section{Aprimoramentos Realizados}

Uma das propostas concebidas pelo orientador foi a integração de um acelerômetro e giroscópio, dispositivo que mede aceleração e posição absoluta, de forma a obter dados espaciais do tórax do paciente. A partir dessa proposta foi elaborado uma interface parar aquisição de dados de pequenos sensores que contém tanto acelerômetro quando giroscópio.

O periférico de giroscópio e acelerômetro escolhido foi o \textit{MPU6050}. Seu baixo custo, alta precisão e plena disponibilidade oferecem um bom dispositivo. O \textit{MPU6050} é conta com 6 \textit{ADCs}, cada um de 16 \textit{bits}. Cada um desses \textit{ADCs} é responsável pela digitalização de um eixo do acelerômetro ou do giroscópio embarcados na \textit{breakout board}. Também oferece um filtro passa-baixas digitalmente programável, descartando a necessidade de pós-processamento e baixo consumo (em torno de \textit{3.6mA} de acordo com a fabricante). 

A expansão incluiu o módulo de acelerômetro e giroscópio \textit{MPU6050}, o que possibilita a captação de sinais de posição em três dimensões com \textit{n}-graus de liberdade, onde \textit{n} é o número de sensores acelerômetro e giroscópio disponíveis no sistema. Claramente existe um limite no número de sensores dado as limitações de memória e hardware disponíveis no sistema. Em específico, o MPU6050 possui um sistema simples de endereçamento, que permite endereçar até dois chips usando apenas um periférico \textit{i\textsuperscript{2}c}. Como a plataforma atual possui dois desses periférico, é possível o endereçamento de até 4 combos de sensores de posição espacial. Qualquer pino pode ser reprogramado para funcionar como este protocolo.

Abaixo são listados os parâmetros de configuração \textit{i\textsuperscript{2}c}.

    \begin{table}[]
        \centering
        \begin{tabular}{|l|l|}
            \hline
            \textbf{Parâmetro}                    & \textbf{Valor} \\ \hline
            Modo de comunicação CC2640R2 & Mestre \\ \hline
            Modo de comunicação MPU6050  & Escravo \\ \hline
            Taxa do clock                & 400kHz \\ \hline
            Tamanho da Amostra           & 16 bits \\ \hline
        \end{tabular}
    \end{table}
    

A metodologia de programação desse periférico se deu no desenvolvimento de um \hyperref[sec:driver]{\textit{driver}} do mesmo, que abstraí rotinas de baixo nível do periférico via uma \textit{API}. Como no programa escrito em Python para recebimento dos dados pela serial, optamos por uma forte filosofia de portabilidade, escrevendo a biblioteca de uma maneira portável e agnóstica à plataforma, podendo ser utilizada em outros microcontroladores e até outros projetos.

A taxa de aquisição desse sensor foi programada em função da taxa de aquisição do \textit{ADC}. A cada disparo do relógio, existe uma simples lógica de contador que divide esse clock afim de realizar a aquisição do acelerômetro + giroscópio. Dessa forma, a taxa de aquisição do acelerômetro + giroscópio nunca pode ser maior do que a do \textit{ADC}. De qualquer forma a taxa de 12MHz do \textit{ADC} é maior que a taxa de 1KHz do acelerômetro e 8kHz do giroscópio.


\chapter{RESULTADOS E DISCUSSÃO}
As condições para realização dos testes não foi propícia devido aos eventos externos ocorridos no ano de 2020, impossibilitando tanto contato quanto acesso aos equipamentos e profissionais necessários para continuar os trabalhos normalmente, dadas as questões sanitárias. De qualquer forma, houveram testes regulares em todas as partes do projeto, o que garante o funcionamento em ambiente de desenvolvimento.

Dado que a forma de conexão dos equipamentos e seu hardware continuaram constantes na realização deste trabalho, a distância de operação entre os equipamentos é, de forma aparente, 10 a 5 metros, a mesma realizada por \cite{willian}. 

O sistema sofre ainda, com falta de estabilidade em certos pontos da conexão. Um aumento nos tempos de atualização do Bluetooth já feitos no trabalho anterior mostraram uma melhora, apesar disso, quedas ainda existem. Se cogita que uma das possíveis soluções seja portar o projeto para utilizar uma versão mais nova do firmware distribuído pela fabricante, que conta com possível correção de bugs e ofereça maior estabilidade.

A falta de estabilidade geral do sistema também é ocasionada pela pouca memória volátil existente no sistema. O tamanho de pacote transmitido pelo protocolo sofreu aumento para acomodar os dados do giroscópio e acelerômetro, causando maior uso na memória volátil. 

Como o firmware escrito para os módulos foi realizado em nível alto e portável dentro da linha suportada pela fabricante, e o driver do acelerômetro e giroscópio também foi escrito com este escopo de portabilidade em mente, se sugere o uso de uma plataforma com maior memória volátil disponível, ou plataforma que possa fazer acesso de memória externa a unidade do microprocessador. A organização interna do código e arquitetura geral do firmware foi desenvolvida em torno da pouca memória volátil disponível. Visando a manutenção do código, uma programação mais orientada e seguindo de forma mais próxima a filosofia de Sistemas Operacionais também se beneficiaria com o aumento da quantidade de memória.


\addcontentsline{toc}{chapter}{REFERÊNCIAS} 
\printbibliography

\nocite{Stallman}
\nocite{Huang}
\label{sec:driver}

\end{document}